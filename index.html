<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WebGL2 OIT Deep Diagnostic - Single File</title>
<style>
  * { box-sizing: border-box; }
  body { 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
    padding: 16px; 
    color: #1a1a1a; 
    line-height: 1.6; 
    background: #f5f5f7;
    margin: 0;
  }
  h3 { margin-top: 0; color: #000; font-size: 18px; }
  pre { 
    background: #fff; 
    padding: 12px; 
    border-radius: 8px; 
    overflow-x: auto; 
    font-size: 11px; 
    border: 1px solid #e0e0e0; 
    white-space: pre-wrap; 
    word-break: break-all;
    max-height: 60vh;
    overflow-y: auto;
  }
  .section { 
    background: #fff; 
    padding: 16px; 
    margin: 12px 0; 
    border-radius: 12px; 
    box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
  }
  .ok { color: #34c759; font-weight: 600; }
  .no { color: #ff3b30; font-weight: 600; }
  .warn { color: #ff9500; font-weight: 600; }
  .info { color: #007aff; font-weight: 600; }
  .critical { color: #ff3b30; font-weight: 700; background: #ffe5e5; padding: 2px 6px; border-radius: 4px; }
  table { border-collapse: collapse; width: 100%; margin: 8px 0; font-size: 13px; }
  td, th { border: 1px solid #e0e0e0; padding: 8px; text-align: left; }
  th { background: #f8f8f8; font-weight: 600; }
  .test-result { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 12px; margin-left: 8px; }
  .test-pass { background: #d4edda; color: #155724; }
  .test-fail { background: #f8d7da; color: #721c24; }
  .test-warn { background: #fff3cd; color: #856404; }
  button { 
    background: #007aff; 
    color: white; 
    border: none; 
    padding: 12px 24px; 
    border-radius: 8px; 
    font-size: 16px; 
    cursor: pointer; 
    margin: 8px 0;
    width: 100%;
  }
  button:active { opacity: 0.8; }
  button:disabled { background: #ccc; cursor: not-allowed; }
  #canvas-container { display: none; }
  .summary-box { 
    background: #f0f0f0; 
    padding: 12px; 
    border-radius: 8px; 
    margin: 8px 0;
    border-left: 4px solid #007aff;
  }
  .error-box {
    background: #ffe5e5;
    border-left-color: #ff3b30;
  }
  .success-box {
    background: #e5f5e5;
    border-left-color: #34c759;
  }
</style>
</head>
<body>
<h3>ğŸ§ª WebGL2 OIT Deep Diagnostic</h3>
<p>iOS 17.7.1 vs 18.6.2 í˜¸í™˜ì„± ë¬¸ì œ íŠ¹í™” íƒì§€<br>
<code>gl.blendFunci</code> ë¯¸ì§€ì› ë° ê¸°íƒ€ iOS WebGL2 ì œí•œì‚¬í•­ ê²€ì¶œ</p>

<div class="section">
  <strong>ìƒíƒœ:</strong> <span id="status">ì¤€ë¹„ë¨ - ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘</span>
  <div id="progress-container" style="margin-top: 8px; height: 4px; background: #e0e0e0; border-radius: 2px; overflow: hidden; display: none;">
    <div id="progress-bar" style="width: 0%; height: 100%; background: #007aff; transition: width 0.3s;"></div>
  </div>
</div>

<button id="start-btn" onclick="runDiagnostics()">ğŸ” ì§„ë‹¨ ì‹œì‘</button>
<button id="copy-btn" onclick="copyResults()" style="display: none; background: #34c759;">ğŸ“‹ ê²°ê³¼ ë³µì‚¬</button>

<pre id="log">ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...</pre>

<div id="summary" style="display: none;"></div>

<div id="canvas-container"></div>

<script>
// ì§„ë‹¨ ê²°ê³¼ ì €ì¥
let finalResults = {};
let logText = '';

function updateStatus(msg) {
  document.getElementById('status').textContent = msg;
  console.log('[Status]', msg);
}

function setProgress(pct) {
  document.getElementById('progress-bar').style.width = pct + '%';
}

function log(title, ...args) {
  const timestamp = new Date().toLocaleTimeString();
  const content = args.map(a => {
    if (a === null) return 'null';
    if (a === undefined) return 'undefined';
    if (typeof a === 'object') return JSON.stringify(a);
    return String(a);
  }).join(' ');
  
  const line = `[${timestamp}] ${title} ${content}`;
  console.log(line);
  
  const logEl = document.getElementById('log');
  logEl.textContent += (logEl.textContent ? '\n' : '') + line;
  logText += line + '\n';
  
  // ìë™ ìŠ¤í¬ë¡¤
  logEl.scrollTop = logEl.scrollHeight;
}

function resultLabel(ok, text) {
  return ok ? 'âœ… ' + text : 'âŒ ' + text;
}

function showSummary(html, type = 'info') {
  const summary = document.getElementById('summary');
  summary.innerHTML = html;
  summary.className = 'section summary-box ' + (type === 'error' ? 'error-box' : type === 'success' ? 'success-box' : '');
  summary.style.display = 'block';
}

async function runDiagnostics() {
  const startBtn = document.getElementById('start-btn');
  const copyBtn = document.getElementById('copy-btn');
  const progressContainer = document.getElementById('progress-container');
  
  startBtn.disabled = true;
  startBtn.textContent = 'â³ í…ŒìŠ¤íŠ¸ ì§„í–‰ì¤‘...';
  progressContainer.style.display = 'block';
  
  // ë¡œê·¸ ì´ˆê¸°í™”
  document.getElementById('log').textContent = '';
  logText = '';
  document.getElementById('summary').style.display = 'none';
  
  // ê²°ê³¼ ê°ì²´ ì´ˆê¸°í™”
  const results = {
    webgl2: false,
    userAgent: navigator.userAgent,
    extensions: {},
    blendFunctions: {},
    floatFBO: {},
    mrt: {},
    depthStencil: {},
    blit: {},
    oit: {},
    timestamp: new Date().toISOString()
  };
  
  try {
    updateStatus('WebGL2 ì»¨í…ìŠ¤íŠ¸ ìƒì„±...');
    setProgress(5);
    
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    document.getElementById('canvas-container').appendChild(canvas);
    
    const gl = canvas.getContext('webgl2', { 
      preserveDrawingBuffer: true,
      antialias: false,
      alpha: false
    });
    
    if (!gl) {
      log('FATAL', 'WebGL2 not supported');
      log('FALLBACK', 'Trying WebGL1...');
      const gl1 = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      const hasGL1 = !!gl1;
      log('WEBGL1', hasGL1 ? 'Available (OIT impossible)' : 'Not available');
      
      showSummary(`
        <strong>âŒ WebGL2 ë¯¸ì§€ì›</strong><br>
        ì´ ê¸°ê¸°/ë¸Œë¼ìš°ì €ëŠ” WebGL2ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.<br>
        WebGL1: ${hasGL1 ? 'ì§€ì›ë¨ (OIT ë¶ˆê°€ëŠ¥)' : 'ë¯¸ì§€ì›'}<br>
        <br>
        <strong>í•´ê²°ì±…:</strong> iOS 15+ Safari ë˜ëŠ” ìµœì‹  Chrome/Edge ì‚¬ìš©
      `, 'error');
      
      finalResults = results;
      startBtn.disabled = false;
      startBtn.textContent = 'ğŸ” ë‹¤ì‹œ ì‹œë„';
      return;
    }
    
    results.webgl2 = true;
    log('SUCCESS', 'WebGL2 context created');
    
    // ê¸°ë³¸ ì •ë³´
    log('\n=== BASIC INFO ===');
    log('VERSION', gl.getParameter(gl.VERSION));
    log('VENDOR', gl.getParameter(gl.VENDOR));
    log('RENDERER', gl.getParameter(gl.RENDERER));
    log('SL_VERSION', gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
    log('MAX_TEXTURE_SIZE', gl.getParameter(gl.MAX_TEXTURE_SIZE));
    log('MAX_DRAW_BUFFERS', gl.getParameter(gl.MAX_DRAW_BUFFERS));
    log('MAX_COLOR_ATTACHMENTS', gl.getParameter(gl.MAX_COLOR_ATTACHMENTS));
    
    // Blend í•¨ìˆ˜ ê°€ìš©ì„± (CRITICAL)
    updateStatus('Blend í•¨ìˆ˜ ê°€ìš©ì„± ê²€ì‚¬...');
    setProgress(10);
    
    log('\n=== BLEND FUNCTIONS (CRITICAL FOR OIT) ===');
    results.blendFunctions = {
      blendFunc: typeof gl.blendFunc === 'function',
      blendFuncSeparate: typeof gl.blendFuncSeparate === 'function',
      blendFunci: typeof gl.blendFunci === 'function',
      blendEquation: typeof gl.blendEquation === 'function',
      blendEquationSeparate: typeof gl.blendEquationSeparate === 'function'
    };
    
    for (const [name, available] of Object.entries(results.blendFunctions)) {
      const isCritical = name === 'blendFunci';
      const marker = isCritical && !available ? 'ğŸ”´' : (available ? 'ğŸŸ¢' : 'ğŸŸ¡');
      log('BLEND', marker, name, available ? 'AVAILABLE' : 'MISSING', isCritical && !available ? '[CRITICAL FOR OIT]' : '');
    }
    
    if (!results.blendFunctions.blendFunci) {
      log('WARNING', 'gl.blendFunci not available!');
      log('IMPACT', 'Per-draw-buffer blending impossible');
      log('IMPACT', 'Standard one-pass Weighted Blended OIT will FAIL');
      log('WORKAROUND', 'Must use two-pass OIT or alternative method');
    }
    
    // Extensions
    updateStatus('í™•ì¥ ê¸°ëŠ¥ ê²€ì‚¬...');
    setProgress(20);
    
    log('\n=== EXTENSIONS ===');
    const extList = [
      'EXT_color_buffer_float',
      'EXT_color_buffer_half_float',
      'WEBGL_draw_buffers',
      'OES_texture_float_linear',
      'OES_texture_half_float_linear',
      'EXT_float_blend',
      'WEBGL_debug_renderer_info',
      'OES_texture_float',
      'OES_texture_half_float'
    ];
    
    for (const name of extList) {
      const ext = gl.getExtension(name);
      results.extensions[name] = !!ext;
      log('EXT', name, ext ? 'âœ…' : 'âŒ');
    }
    
    // GPU ì •ë³´
    const dbg = gl.getExtension('WEBGL_debug_renderer_info');
    if (dbg) {
      log('\n=== GPU INFO ===');
      log('UNMASKED_VENDOR', gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL));
      log('UNMASKED_RENDERER', gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL));
      results.gpuVendor = gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL);
      results.gpuRenderer = gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL);
    }
    
    // Helper
    function createTexture(w, h, internalFormat, format, type) {
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return tex;
    }
    
    function checkFBO(label) {
      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      const map = {
        0x8CD5: 'COMPLETE',
        0x8CD6: 'INCOMPLETE_ATTACHMENT',
        0x8CD7: 'INCOMPLETE_MISSING_ATTACHMENT',
        0x8CD9: 'UNSUPPORTED',
        0x8D56: 'INCOMPLETE_MULTISAMPLE'
      };
      const str = map[status] || `0x${status.toString(16)}`;
      const ok = status === gl.FRAMEBUFFER_COMPLETE;
      log('FBO', label, str, ok ? 'âœ…' : 'âŒ');
      return ok;
    }
    
    // Test 1: Float FBO ë‹¨ì¼
    updateStatus('Float FBO í…ŒìŠ¤íŠ¸...');
    setProgress(30);
    
    log('\n=== TEST 1: Single Float FBO ===');
    
    const formats = [
      { key: 'rgba32f', name: 'RGBA32F', internal: gl.RGBA32F, format: gl.RGBA, type: gl.FLOAT, needExt: 'EXT_color_buffer_float' },
      { key: 'rgba16f', name: 'RGBA16F', internal: gl.RGBA16F, format: gl.RGBA, type: gl.HALF_FLOAT, needExt: 'EXT_color_buffer_half_float' },
      { key: 'rg32f', name: 'RG32F', internal: gl.RG32F, format: gl.RG, type: gl.FLOAT, needExt: 'EXT_color_buffer_float' },
      { key: 'rg16f', name: 'RG16F', internal: gl.RG16F, format: gl.RG, type: gl.HALF_FLOAT, needExt: 'EXT_color_buffer_half_float' }
    ];
    
    for (const fmt of formats) {
      if (!results.extensions[fmt.needExt]) {
        log('SKIP', fmt.name, 'extension not available');
        results.floatFBO[fmt.key] = false;
        continue;
      }
      
      const fb = gl.createFramebuffer();
      const tex = createTexture(64, 64, fmt.internal, fmt.format, fmt.type);
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
      results.floatFBO[fmt.key] = checkFBO(fmt.name);
      
      gl.deleteFramebuffer(fb);
      gl.deleteTexture(tex);
    }
    
    // Test 2: MRT
    updateStatus('MRT (ë‹¤ì¤‘ ë Œë” íƒ€ê²Ÿ) í…ŒìŠ¤íŠ¸...');
    setProgress(45);
    
    log('\n=== TEST 2: Multiple Render Targets ===');
    
    // 2.1 RGBA8+RGBA8
    {
      const fb = gl.createFramebuffer();
      const t0 = createTexture(64, 64, gl.RGBA8, gl.RGBA, gl.UNSIGNED_BYTE);
      const t1 = createTexture(64, 64, gl.RGBA8, gl.RGBA, gl.UNSIGNED_BYTE);
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, t0, 0);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, t1, 0);
      gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
      results.mrt.rgba8_rgba8 = checkFBO('MRT RGBA8+RGBA8');
      gl.deleteFramebuffer(fb);
      gl.deleteTexture(t0);
      gl.deleteTexture(t1);
    }
    
    // 2.2 RGBA8+RGBA32F (Babylon OIT íŒ¨í„´)
    if (results.extensions['EXT_color_buffer_float'] && results.floatFBO.rgba32f) {
      const fb = gl.createFramebuffer();
      const t0 = createTexture(64, 64, gl.RGBA8, gl.RGBA, gl.UNSIGNED_BYTE);
      const t1 = createTexture(64, 64, gl.RGBA32F, gl.RGBA, gl.FLOAT);
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, t0, 0);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, t1, 0);
      gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
      results.mrt.rgba8_rgba32f = checkFBO('MRT RGBA8+RGBA32F');
      
      if (results.mrt.rgba8_rgba32f) {
        // ë Œë”ë§ í…ŒìŠ¤íŠ¸
        log('RENDER', 'Testing MRT shader...');
        const vs = gl.createShader(gl.VERTEX_SHADER);
        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vs, `#version 300 es
          in vec2 aPos;
          void main() { gl_Position = vec4(aPos, 0.0, 1.0); }`);
        gl.shaderSource(fs, `#version 300 es
          precision highp float;
          layout(location=0) out vec4 out0;
          layout(location=1) out vec4 out1;
          void main() {
            out0 = vec4(1.0, 0.0, 0.0, 0.5);
            out1 = vec4(0.0, 1.0, 0.0, 0.5);
          }`);
        gl.compileShader(vs);
        gl.compileShader(fs);
        
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        
        if (gl.getProgramParameter(prog, gl.LINK_STATUS)) {
          gl.useProgram(prog);
          const vao = gl.createVertexArray();
          gl.bindVertexArray(vao);
          const vbo = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
          gl.viewport(0, 0, 64, 64);
          gl.drawArrays(gl.TRIANGLES, 0, 3);
          
          // Readback
          gl.readBuffer(gl.COLOR_ATTACHMENT0);
          const b0 = new Uint8Array(4);
          gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, b0);
          log('READBACK', 'RGBA8:', Array.from(b0));
          
          gl.readBuffer(gl.COLOR_ATTACHMENT1);
          const b1 = new Float32Array(4);
          gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, b1);
          log('READBACK', 'RGBA32F:', Array.from(b1).map(v => v.toFixed(2)));
          
          results.mrt.renderSuccess = (b0[0] > 200);
          log('MRT_RENDER', results.mrt.renderSuccess ? 'âœ… Shader wrote to both targets' : 'âŒ Render failed');
        } else {
          log('MRT_SHADER', 'âŒ Link failed:', gl.getProgramInfoLog(prog));
          results.mrt.renderSuccess = false;
        }
      }
      
      gl.deleteFramebuffer(fb);
      gl.deleteTexture(t0);
      gl.deleteTexture(t1);
    } else {
      log('SKIP', 'MRT RGBA8+RGBA32F (float not available)');
      results.mrt.rgba8_rgba32f = false;
    }
    
    // 2.3 RGBA16F+RGBA16F
    if (results.extensions['EXT_color_buffer_half_float']) {
      const fb = gl.createFramebuffer();
      const t0 = createTexture(64, 64, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT);
      const t1 = createTexture(64, 64, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT);
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, t0, 0);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, t1, 0);
      gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
      results.mrt.rgba16f_rgba16f = checkFBO('MRT RGBA16F+RGBA16F');
      gl.deleteFramebuffer(fb);
      gl.deleteTexture(t0);
      gl.deleteTexture(t1);
    }
    
    // Test 3: Depth ì¡°í•©
    updateStatus('Depth/Stencil ì¡°í•© í…ŒìŠ¤íŠ¸...');
    setProgress(60);
    
    log('\n=== TEST 3: Depth/Stencil Combinations ===');
    
    // Float + Depth24_Stencil8
    if (results.floatFBO.rgba32f) {
      const fb = gl.createFramebuffer();
      const color = createTexture(64, 64, gl.RGBA32F, gl.RGBA, gl.FLOAT);
      const depth = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, depth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH24_STENCIL8, 64, 64);
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, color, 0);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depth);
      results.depthStencil.float32_depth24stencil8 = checkFBO('RGBA32F + DEPTH24_STENCIL8');
      gl.deleteFramebuffer(fb);
      gl.deleteTexture(color);
      gl.deleteRenderbuffer(depth);
    }
    
    // Float only (no depth) - iOS 17 íŠ¹ìˆ˜ ì¼€ì´ìŠ¤
    if (results.floatFBO.rgba32f) {
      const fb = gl.createFramebuffer();
      const color = createTexture(64, 64, gl.RGBA32F, gl.RGBA, gl.FLOAT);
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, color, 0);
      results.depthStencil.float32_only = checkFBO('RGBA32F only (no depth)');
      gl.deleteFramebuffer(fb);
      gl.deleteTexture(color);
    }
    
    // Test 4: Blit
    updateStatus('BlitFramebuffer í…ŒìŠ¤íŠ¸...');
    setProgress(75);
    
    log('\n=== TEST 4: Blit Operations ===');
    
    if (results.mrt.rgba8_rgba32f) {
      const srcFb = gl.createFramebuffer();
      const srcTex = createTexture(64, 64, gl.RGBA32F, gl.RGBA, gl.FLOAT);
      gl.bindFramebuffer(gl.FRAMEBUFFER, srcFb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, srcTex, 0);
      gl.clearColor(0, 1, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
      
      const dstFb = gl.createFramebuffer();
      const dstTex = createTexture(64, 64, gl.RGBA8, gl.RGBA, gl.UNSIGNED_BYTE);
      gl.bindFramebuffer(gl.FRAMEBUFFER, dstFb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, dstTex, 0);
      
      try {
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFb);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFb);
        gl.blitFramebuffer(0, 0, 64, 64, 0, 0, 64, 64, gl.COLOR_BUFFER_BIT, gl.NEAREST);
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, dstFb);
        const buf = new Uint8Array(4);
        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, buf);
        results.blit.floatToByte = (buf[1] > 200);
        log('BLIT', 'Float->Byte:', results.blit.floatToByte ? 'âœ…' : 'âŒ', 'Pixel:', Array.from(buf));
      } catch(e) {
        log('BLIT_ERROR', e.message);
        results.blit.floatToByte = false;
      }
      
      gl.deleteFramebuffer(srcFb);
      gl.deleteFramebuffer(dstFb);
      gl.deleteTexture(srcTex);
      gl.deleteTexture(dstTex);
    } else {
      log('SKIP', 'Blit test (float MRT unavailable)');
    }
    
    // Test 5: OIT ì‹œë®¬ë ˆì´ì…˜
    updateStatus('OIT ì‹œë®¬ë ˆì´ì…˜...');
    setProgress(90);
    
    log('\n=== TEST 5: OIT Simulation ===');
    
    // blendFunci ì—†ëŠ” ê²½ìš° (iOS) - Two-pass workaround í…ŒìŠ¤íŠ¸
    if (!results.blendFunctions.blendFunci) {
      log('MODE', 'Two-pass OIT (blendFunci unavailable)');
      
      if (!results.mrt.rgba8_rgba32f && !results.mrt.rgba16f_rgba16f) {
        log('OIT_FAIL', 'No suitable MRT format available');
        results.oit.possible = false;
      } else {
        const useHalf = results.mrt.rgba16f_rgba16f;
        const internalFmt = useHalf ? gl.RGBA16F : gl.RGBA32F;
        const pixelType = useHalf ? gl.HALF_FLOAT : gl.FLOAT;
        
        const fb = gl.createFramebuffer();
        const accumTex = createTexture(128, 128, internalFmt, gl.RGBA, pixelType);
        const revealTex = createTexture(128, 128, internalFmt, gl.RGBA, pixelType);
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        
        // Pass 1: Accumulation only
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, accumTex, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, null, 0);
        gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
        
        if (checkFBO('Pass 1: Accum only')) {
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.ONE, gl.ONE); // Global blend
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
          
          // Draw
          const vs = gl.createShader(gl.VERTEX_SHADER);
          const fs = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(vs, `#version 300 es
            in vec2 aPos;
            void main() { gl_Position = vec4(aPos, 0.0, 1.0); }`);
          gl.shaderSource(fs, `#version 300 es
            precision highp float;
            layout(location=0) out vec4 accum;
            void main() { accum = vec4(1.0, 0.5, 0.0, 0.8); }`);
          gl.compileShader(vs);
          gl.compileShader(fs);
          const prog = gl.createProgram();
          gl.attachShader(prog, vs);
          gl.attachShader(prog, fs);
          gl.linkProgram(prog);
          gl.useProgram(prog);
          
          const vao = gl.createVertexArray();
          gl.bindVertexArray(vao);
          const vbo = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
          gl.drawArrays(gl.TRIANGLES, 0, 3);
          
          // Check
          gl.readBuffer(gl.COLOR_ATTACHMENT0);
          const buf = useHalf ? new Uint16Array(4) : new Float32Array(4);
          gl.readPixels(0, 0, 1, 1, gl.RGBA, pixelType, buf);
          const val = useHalf ? buf[0] : buf[0];
          const success = useHalf ? (val > 0) : (val > 0.5);
          log('PASS1', success ? 'âœ… Accumulation written' : 'âŒ Failed', Array.from(buf).map(v => useHalf ? v : v.toFixed(2)));
          
          results.oit.twoPassPossible = success;
          results.oit.possible = success;
        } else {
          results.oit.possible = false;
        }
        
        gl.deleteFramebuffer(fb);
        gl.deleteTexture(accumTex);
        gl.deleteTexture(revealTex);
      }
    } else {
      // blendFunci ìˆëŠ” ê²½ìš° - One-pass í…ŒìŠ¤íŠ¸
      log('MODE', 'One-pass OIT (blendFunci available)');
      results.oit.onePassPossible = results.mrt.rgba8_rgba32f || results.mrt.rgba16f_rgba16f;
      results.oit.possible = results.oit.onePassPossible;
    }
    
    // ìµœì¢… ê²°ê³¼
    updateStatus('í…ŒìŠ¤íŠ¸ ì™„ë£Œ');
    setProgress(100);
    
    finalResults = results;
    
    // ìš”ì•½ ìƒì„±
    log('\n========================================');
    log('FINAL SUMMARY');
    log('========================================');
    
    const summaryLines = [];
    summaryLines.push(`<strong>WebGL2:</strong> ${results.webgl2 ? 'âœ…' : 'âŒ'}`);
    summaryLines.push(`<strong>gl.blendFunci:</strong> ${results.blendFunctions.blendFunci ? 'âœ…' : '<span class="critical">âŒ CRITICAL</span>'}`);
    summaryLines.push(`<strong>Float32 FBO:</strong> ${results.floatFBO.rgba32f ? 'âœ…' : 'âŒ'}`);
    summaryLines.push(`<strong>Float16 FBO:</strong> ${results.floatFBO.rgba16f ? 'âœ…' : 'âŒ'}`);
    summaryLines.push(`<strong>Basic MRT:</strong> ${results.mrt.rgba8_rgba8 ? 'âœ…' : 'âŒ'}`);
    summaryLines.push(`<strong>Float MRT:</strong> ${results.mrt.rgba8_rgba32f ? 'âœ…' : 'âŒ'}`);
    summaryLines.push(`<strong>OIT Possible:</strong> ${results.oit.possible ? 'âœ…' : 'âŒ'}`);
    
    let diagnosis = '';
    let summaryType = 'info';
    
    if (!results.webgl2) {
      diagnosis = '<strong>âŒ WebGL2 ë¯¸ì§€ì›</strong><br>ë¸Œë¼ìš°ì €ê°€ WebGL2ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.';
      summaryType = 'error';
    } else if (!results.blendFunctions.blendFunci) {
      if (results.oit.twoPassPossible) {
        diagnosis = '<strong>âš ï¸ ì œí•œì  OIT ì§€ì›</strong><br>gl.blendFunci ë¯¸ì§€ì›ìœ¼ë¡œ í‘œì¤€ OITëŠ” ë¶ˆê°€ëŠ¥í•˜ì§€ë§Œ, Two-pass WorkaroundëŠ” ê°€ëŠ¥í•©ë‹ˆë‹¤.<br><br><strong>Babylon.js ìˆ˜ì • í•„ìš”:</strong> iOS ê°ì§€ ì‹œ ìë™ìœ¼ë¡œ two-pass ëª¨ë“œë¡œ ì „í™˜';
        summaryType = 'warn';
      } else {
        diagnosis = '<strong>âŒ OIT ë¶ˆê°€ëŠ¥</strong><br>gl.blendFunci ë¯¸ì§€ì› + MRT Float ë¶ˆê°€ë¡œ OITë¥¼ êµ¬í˜„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
        summaryType = 'error';
      }
    } else if (!results.oit.possible) {
      diagnosis = '<strong>âŒ OIT ë¶ˆê°€ëŠ¥</strong><br>MRT Float FBO ìƒì„± ì‹¤íŒ¨ë¡œ OITë¥¼ êµ¬í˜„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
      summaryType = 'error';
    } else {
      diagnosis = '<strong>âœ… OIT ì™„ì „ ì§€ì›</strong><br>ëª¨ë“  í•„ìš” ê¸°ëŠ¥ì´ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.';
      summaryType = 'success';
    }
    
    showSummary(`
      <div style="margin-bottom: 12px;">${summaryLines.join('<br>')}</div>
      <div style="border-top: 1px solid #ddd; padding-top: 12px; margin-top: 12px;">
        ${diagnosis}
      </div>
    `, summaryType);
    
    // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
    startBtn.disabled = false;
    startBtn.textContent = 'ğŸ” ë‹¤ì‹œ ì‹œë„';
    copyBtn.style.display = 'block';
    
  } catch (err) {
    log('FATAL_ERROR', err.message);
    updateStatus('ì˜¤ë¥˜ ë°œìƒ');
    startBtn.disabled = false;
    startBtn.textContent = 'ğŸ” ë‹¤ì‹œ ì‹œë„';
  }
}

function copyResults() {
  const textToCopy = `WebGL2 OIT Diagnostic Results\n` +
    `Timestamp: ${finalResults.timestamp}\n` +
    `User Agent: ${finalResults.userAgent}\n` +
    `GPU: ${finalResults.gpuRenderer || 'Unknown'}\n` +
    `Vendor: ${finalResults.gpuVendor || 'Unknown'}\n\n` +
    `WebGL2: ${finalResults.webgl2}\n` +
    `blendFunci: ${finalResults.blendFunctions?.blendFunci}\n` +
    `Float32 FBO: ${finalResults.floatFBO?.rgba32f}\n` +
    `Float16 FBO: ${finalResults.floatFBO?.rgba16f}\n` +
    `Basic MRT: ${finalResults.mrt?.rgba8_rgba8}\n` +
    `Float MRT: ${finalResults.mrt?.rgba8_rgba32f}\n` +
    `OIT Possible: ${finalResults.oit?.possible}\n\n` +
    `Full Log:\n${logText}`;
  
  if (navigator.clipboard) {
    navigator.clipboard.writeText(textToCopy).then(() => {
      alert('ê²°ê³¼ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
    }).catch(() => {
      // Fallback
      const textarea = document.createElement('textarea');
      textarea.value = textToCopy;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
      alert('ê²°ê³¼ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
    });
  } else {
    // Final fallback
    const textarea = document.createElement('textarea');
    textarea.value = textToCopy;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    document.body.removeChild(textarea);
    alert('ê²°ê³¼ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
  }
}

// í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ ì‹¤í–‰ ì—¬ë¶€ (ì›í•˜ë©´ ì£¼ì„ í•´ì œ)
// window.addEventListener('load', () => setTimeout(runDiagnostics, 500));
</script>
</body>
</html>
